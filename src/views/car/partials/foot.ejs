
<!-- WRAPPER -->
</div>

<script src="/scripts/common.js"></script> 

<!-- SCRIPT LOADER -->
<script>    

    let firststart = true;

    // Websockets
    var ws_hardware = null;

    // GPS
    var GPS_last = {"lat": 0, "lng": 0, "speed": 0, "alt": 0, "track": 0, "climb": 0, "precision": "(-1, -1)", "sats": 0};
    var GPS_now = {"lat": 0, "lng": 0, "speed": 0, "alt": 0, "track": 0, "climb": 0, "precision": "(-1, -1)", "sats": 0};
    var GPS_meanSum = {"lat": 0, "lng": 0, "speed": 0, "alt": 0, "track": 0, "climb": 0};
    var GPS_meanNum = 0;
    var GPS_hasChanged = () => {};
    var GPS_hasFIX = false;
    var GPS_alt_max = parseInt(localStorage.getItem('gps.altMax') || 0);
    var GPS_alt_min = parseInt(localStorage.getItem('gps.altMin') || 0);
    var GPS_dist_sum = parseInt(localStorage.getItem('gps.distSum') || 0);				

    // Raspberry PI Infos
    var status_memFree = 0;
    var status_memTotal = 0;
    var status_cpuTemp = 0;
    var status_wpaSupp = "";
    var status_connWlan = "";
    var status_cpuIdle = 0;
    var status_hostname = "";
    var status_usbtether = false;

    let loaderFunction = () => {};

    const url_login = '/api/v1/auth/login';

    var serviceWorker_registration = null;

    // -------- Update a Service Worker--------
    function invokeServiceWorkerUpdateFlow(registration) {
        // TODO implement your own UI notification element
        alert("Update... Bitte warten ...");
        notification.show("New version of the app is available. Refresh now?");
        notification.addEventListener('click', () => {
            if (registration.waiting) {
                // let waiting Servi<ce Worker know it should became active
                registration.waiting.postMessage('SKIP_WAITING')
            }
        })
    }

    // -------- Register a Service Worker--------
    async function serviceWorker_run() {

        // Registriere Service Worker
        console.log('Registering service worker');	
        serviceWorker_registration = await navigator.serviceWorker.
            register('/serviceworker_car.js', { scope: "/car/" });
            

            // updatefound is fired if service-worker.js changes.
            serviceWorker_registration.onupdatefound = function() {
                var installingWorker = serviceWorker_registration.installing;

                installingWorker.onstatechange = function() {
                    switch (installingWorker.state) {
                        case 'installed':
                            if (navigator.serviceWorker.controller) {
                                // At this point, the old content will have been purged and the fresh content will
                                // have been added to the cache.
                                // It's the perfect time to display a "New content is available; please refresh."
                                // message in the page's interface.
                                console.log('New or updated content is available.');
                                if(!alert("update....")) window.location.reload();
                            } else {
                                // At this point, everything has been precached.
                                // It's the perfect time to display a "Content is cached for offline use." message.
                                console.log('Content is now available offline!');
                            }
                            break;

                        case 'redundant':
                            console.error('The installing service worker became redundant.');
                            break;
                    }
                };
            };
            


        console.log('Registered service worker');

        // ensure the case when the updatefound event was missed is also handled
        // by re-invoking the prompt when there's a waiting Service Worker
        if (serviceWorker_registration.waiting) {
            invokeServiceWorkerUpdateFlow(serviceWorker_registration)
        }

        console.log('waiting for ready...');

        await navigator.serviceWorker.ready;

        console.log('Registered service worker is now ready');
    }


    /**
    *   https://gist.github.com/viktorbezdek/3957601
    *	Distance between two points
    * 	@param coords1 {lat: xx, lng: yy}
    * 	@param coords2 {lat: xx, lng: yy}
    * 	@returnd distance in meters
    */
    function _getCoordsDistance(coords1, coords2)
    {
        // earth
        var R = 6371, // km
            lat1 = parseFloat(coords1.lat),
            lat2 = parseFloat(coords2.lat),
            lon1 = parseFloat(coords1.lng),
            lon2 = parseFloat(coords2.lng);
        
        // deg2rad
        lat1 = (lat1 / 180) * Math.PI;
        lat2 = (lat2 / 180) * Math.PI;
        lon1 = (lon1 / 180) * Math.PI;
        lon2 = (lon2 / 180) * Math.PI;
            
        // Equirectangular approximation
        // lower accuracy, higher performance
        var x = (lon2-lon1) * Math.cos((lat1+lat2)/2);
        var y = (lat2-lat1);
        var d = Math.sqrt(x*x + y*y) * R;
        return Math.round(d * 1000);
    }

    function _getCoordsDistance_accurate(coords1, coords2) {
        let lat1 = coords1.lat;
        let lon1 = coords1.lng;
        let lat2 = coords2.lat;
        let lon2 = coords2.lng;

        var R = 6371; // km
        var dLat = (lat2 - lat1) * Math.PI / 180;
        var dLon = (lon2 - lon1) * Math.PI / 180; 
        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                Math.sin(dLon / 2) * Math.sin(dLon / 2); 
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); 
        var d = R * c;
        return d * 1000;
    }
    Number.prototype.toRad = function() {
        return this * Math.PI / 180;
    }

    /**
     * Aktualisieren der gefahrenen Wegstrecke
     * @param _POS_last {lat: xx, lng: yy}
     * @param _POS_now {lat: xx, lng: yy}
    */
    function updateDistance(_POS_last, _POS_now) {
        let dist = _getCoordsDistance_accurate(_POS_last, _POS_now);
        GPS_dist_sum += _getCoordsDistance_accurate(_POS_last, _POS_now);				
    }			

    // Websocket für GPS, Displaysteuerung
    function connectSteuer() {			
        ws_hardware = new WebSocket('ws://localhost:8765');
        let wsGPSInterval = null;				
        
        ws_hardware.onopen = function() {
            console.log("Hardware-connection socket connected:");
            // Setze GPS Status auf kein FIX
            index_status_GPS(1);
            // Interval GPS Positionsabfrage
            wsGPSInterval = setInterval( () => { 
                ws_hardware.send('getGPS'); 
                ws_hardware.send('getMemFree'); 
                ws_hardware.send('getMemTotal'); 
                ws_hardware.send('getCpuTemp'); 
                ws_hardware.send('getConnWlan'); 
                ws_hardware.send('getCpuIdle'); 	
                ws_hardware.send('getUsbtether'); 						
            }, 1500);
            ws_hardware.send('getWpaSupp'); 
            ws_hardware.send('getHostname'); 
        };

        ws_hardware.onmessage = function(e) {
            console.log("Hardware-connection socket data received: " + e.data);
            // Kein FIX
            if(e.data == "-1") {
                index_status_GPS(1);

            } else if (e.data.indexOf('memFree') != -1) {
                status_memFree = e.data.split(':')[1];

            } else if (e.data.indexOf('memTotal') != -1) {
                status_memTotal = e.data.split(':')[1];

            } else if (e.data.indexOf('wpaSupp') != -1) {
                status_wpaSupp = e.data.split(':')[1];

            } else if (e.data.indexOf('cpuTemp') != -1) {
                status_cpuTemp = e.data.split(':')[1];

            } else if (e.data.indexOf('connWlan') != -1) {
                status_connWlan = e.data.split(':')[1];

            } else if (e.data.indexOf('cpuIdle') != -1) {
                status_cpuIdle = e.data.split(':')[1];

            } else if (e.data.indexOf('hostname') != -1) {
                status_hostname = e.data.split(':')[1];

            } else if (e.data.indexOf('setWpaSupp') != -1) {
                closeLoading();
                alert('Daten gespeichert!');

            } else if (e.data.indexOf('usbtether') != -1) {
                status_usbtether = e.data.split(':')[1] == "true";

                

            } else {
                // Positionsdaten verarbeiten
                let dat = JSON.parse(e.data);

                // Status anzeigen
                index_status_GPS(dat.mode);

                // Daten Aufsummieren -> Mittelwert
                GPS_meanSum.lat += dat.lat;
                GPS_meanSum.lng += dat.lng;
                GPS_meanSum.speed += dat.speed;
                GPS_meanSum.alt += dat.alt;
                GPS_meanSum.track += dat.track;
                GPS_meanSum.climb += dat.climb;
                GPS_meanNum++;
                // Kein 3D FIX -> Höhe rücksetzen
                if(dat.mode < 3) GPS_meanSum.alt = 0;

                // Mittelwert berechnen
                if(GPS_meanNum >= 3) {
                    GPS_meanSum.lat /= GPS_meanNum;
                    GPS_meanSum.lng /= GPS_meanNum;
                    GPS_meanSum.speed /= GPS_meanNum;
                    GPS_meanSum.alt /= GPS_meanNum;
                    GPS_meanSum.track /= GPS_meanNum;
                    GPS_meanSum.climb /= GPS_meanNum;							

                    // Abweichung von letzter Position berechnen
                    if(GPS_now) {
                        let d = _getCoordsDistance({lng: GPS_meanSum.lng, lat: GPS_meanSum.lat}, {lng: GPS_now.lng, lat: GPS_now.lat});
//								console.log("Distanz", d);
                        if(d >= 2) {
                            if(GPS_last.lat != 0 && GPS_last.speed > 5) updateDistance({lat: GPS_now.lat, lng: GPS_now.lng}, {lng: GPS_meanSum.lng, lat: GPS_meanSum.lat});
                            console.log("GPS Change", GPS_meanSum);
                            GPS_hasChanged();									
                        }
                    }

                    GPS_last.lat = GPS_now.lat;
                    GPS_last.lng = GPS_now.lng;
                    GPS_last.speed = GPS_now.speed;
                    GPS_last.alt = GPS_now.alt;
                    GPS_last.track = GPS_now.track;
                    GPS_last.climb = GPS_now.climb;

                    // Positionsdaten speichern
                    GPS_now.lat = GPS_meanSum.lat.toFixed(5);
                    GPS_now.lng = GPS_meanSum.lng.toFixed(5);
                    GPS_now.speed = Math.round(GPS_meanSum.speed);
                    GPS_now.alt = Math.round(GPS_meanSum.alt);
                    GPS_now.track = Math.round(GPS_meanSum.track);
                    GPS_now.climb = Math.round(GPS_meanSum.climb);
                    GPS_now.precision = dat.precision;
                    GPS_now.sats = dat.sats;

                    // Höhe Min/Max
                    if(GPS_alt_max < GPS_now.alt) GPS_alt_max = GPS_now.alt;
                    if(GPS_alt_min > GPS_now.alt && GPS_now.alt != 0) GPS_alt_min = GPS_now.alt;
                    localStorage.setItem('gps.altMax', GPS_alt_max);
                    localStorage.setItem('gps.altMin', GPS_alt_min);
                    localStorage.setItem('gps.distSum', GPS_dist_sum);

                    // Summen rücksetzen
                    GPS_meanSum.lat = 0;
                    GPS_meanSum.lng = 0;
                    GPS_meanSum.speed = 0;
                    GPS_meanSum.alt = 0;
                    GPS_meanSum.track = 0;
                    GPS_meanSum.climb = 0;
                    GPS_meanNum = 0;							
                }
            } 
        };

        ws_hardware.onclose = function(e) {
            console.log('Hardware-connection socket is closed. Reconnect will be attempted in 1 second.', e.reason);
            // Setze GPS Status auf Fehler
            index_status_GPS(-1);	
            // Lösche GPS Abfrageintervall
            clearInterval(wsGPSInterval);

            // Nach 1s neu verbinden
            setTimeout(function() {
                connectSteuer();
            }, 1000);					
        };

        ws_hardware.onerror = function(err) {
            console.error('Hardware-connection socket encountered error: ', err.message, 'Closing socket');
            // Setze GPS Status auf Fehler
            index_status_GPS(-1);
            // Lösche GPS Abfrageintervall
            clearInterval(wsGPSInterval);
            // Verbindung schließen
            ws_hardware.close();
        };
    }			

    
    async function initialLoad() {

        //connectSteuer();          
        
        console.log('Initiate Service Worker');
        await serviceWorker_run().catch(error => console.error(error));

        let refreshing = false;
        // detect controller change and refresh the page
        navigator.serviceWorker.addEventListener('controllerchange', () => {
            if (!refreshing) {
                //if(!alert("update...."))
                //window.location.reload()
                refreshing = true
            }
        })

        // -------- Feature Detection --------
        if ('serviceWorker' in navigator) {
            if (Notification.permission === "granted") {
                getNotificationPermission();
            }

        }

        firststart = false;

        console.log('initialLoad .. DONE');
        
    }


    // **** Events ****
    document.addEventListener('readystatechange', event => { 
        console.log('readyState --> ' + event.target.readyState);

        // When HTML/DOM elements are ready:
        if (event.target.readyState === "interactive") {   //does same as:  ..addEventListener("DOMContentLoaded"..
            
        }

        // When window loaded ( external resources are loaded too- `css`,`src`, etc...) 
        if (event.target.readyState === "complete") {            
                       
        }
    });

    window.addEventListener('load', async (event) => {
        console.log('The page has fully loaded');
        try {
            await initialLoad();  
        } catch (error) {
            console.error(error);            
        }
        await loaderFunction();
         
        console.log('Loader function done');
        loaderOut();    
    });

    window.addEventListener('onpageshow', (event) => {
        console.log('The page has been shown');
        loaderOut();  
    });
   
    window.addEventListener("click", (event) => {
        if (event.target.classList.contains('modal')) {
            event.target.style.display = "none";
        }
    }, false);

    window.onunload = function(){
        console.log('The page is unloading');
    };   
    
    window.addEventListener("visibilitychange", async () => {
        console.log(document.visibilityState, firststart);

        if (document.visibilityState === 'visible' && !firststart) {
            console.log("open");

            const userrights = await fetch_get('/api/v1/user/rights', true)
            .catch((err) => {location.reload()});
            console.log('userrights', userrights);    
            
            if(userrights == undefined) location.reload();

        } else {
            console.log("close");
        }
    });
  


    


</script>

